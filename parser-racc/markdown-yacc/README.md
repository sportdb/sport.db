## q: can you give a lalr(1) grammar example of a markdown-like language?

Sure! Here's an example of an LALR(1) grammar for a simple markdown-like language using Yacc/Bison syntax. This example will include basic elements like headers, bold text, italic text, and paragraphs.

```yacc
%{
#include <stdio.h>
#include <stdlib.h>
%}

%token HEADER1 HEADER2 HEADER3 BOLD ITALIC TEXT

%%
document:
    elements
    ;

elements:
    element elements
    | /* empty */
    ;

element:
    header
    | paragraph
    ;

header:
    HEADER1 TEXT { printf("<h1>%s</h1>\n", $2); }
    | HEADER2 TEXT { printf("<h2>%s</h2>\n", $2); }
    | HEADER3 TEXT { printf("<h3>%s</h3>\n", $2); }
    ;

paragraph:
    TEXT { printf("<p>%s</p>\n", $1); }
    | formatted_text { printf("<p>%s</p>\n", $1); }
    ;

formatted_text:
    BOLD TEXT BOLD { $$ = "<b>" $2 "</b>"; }
    | ITALIC TEXT ITALIC { $$ = "<i>" $2 "</i>"; }
    ;

%%

int main() {
    yyparse();
    return 0;
}

int yyerror(char *s) {
    fprintf(stderr, "Error: %s\n", s);
    return 0;
}
```

### Explanation:

1. **Tokens**:
   - `HEADER1`, `HEADER2`, `HEADER3`: Represent headers of different levels (e.g., `#`, `##`, `###`).
   - `BOLD`, `ITALIC`: Represent bold and italic markers (e.g., `**`, `*`).
   - `TEXT`: Represents plain text.

2. **Grammar Rules**:
   - `document`: The starting rule that consists of multiple `elements`.
   - `elements`: A list of `element` rules. It can be empty or consist of one or more `element` rules.
   - `element`: Can be either a `header` or a `paragraph`.
   - `header`: Produces HTML `<h1>`, `<h2>`, or `<h3>` tags based on the header level.
   - `paragraph`: Produces an HTML `<p>` tag containing plain text or formatted text.
   - `formatted_text`: Handles bold and italic text and produces corresponding HTML tags.

### Usage:

This grammar can be used with a lexer to parse a simple markdown-like language and convert it into HTML. The lexer would be responsible for recognizing tokens like `HEADER1`, `HEADER2`, `BOLD`, `ITALIC`, and `TEXT`.

### Example Input:

```
# Header 1
## Header 2
### Header 3
This is a paragraph.
**This is bold text.**
*This is italic text.*
```

### Expected Output:

```html
<h1>Header 1</h1>
<h2>Header 2</h2>
<h3>Header 3</h3>
<p>This is a paragraph.</p>
<p><b>This is bold text.</b></p>
<p><i>This is italic text.</i></p>
```

This example provides a basic structure for a markdown-like language parser. You can extend it further by adding more markdown features like lists, links, images, etc.

---

## q:  can you change the sample to use racc / ruby?

a:  Sure! Here's an example of an LALR(1) grammar for a simple markdown-like language using Racc, which is a parser generator for Ruby.

First, you'll need to install Racc if you haven't already. You can do this by running:

```sh
gem install racc
```

### Lexer (Tokenizer)

We'll start by defining a simple lexer using Ruby. This lexer will tokenize the input markdown-like text.

```ruby
# lexer.rb
class Lexer
  TOKENS = {
    /^#\s+(.*)$/ => :HEADER1,
    /^##\s+(.*)$/ => :HEADER2,
    /^###\s+(.*)$/ => :HEADER3,
    /^\*\*(.*?)\*\*/ => :BOLD,
    /^\*(.*?)\*/ => :ITALIC,
    /^(.*)$/ => :TEXT
  }

  def initialize(input)
    @input = input.split("\n")
    @lineno = 0
  end

  def next_token
    return if @input.empty?

    line = @input.shift.strip
    @lineno += 1

    TOKENS.each do |regex, token|
      if match = regex.match(line)
        return [token, match[1]]
      end
    end

    nil
  end
end
```

### Parser

Next, we'll define the parser using Racc. This parser will use the tokens generated by the lexer and produce HTML output.

```ruby
# parser.y
require 'racc/parser'
require './lexer'

class MarkdownParser < Racc::Parser
  def initialize(lexer)
    @lexer = lexer
  end

  def next_token
    @lexer.next_token
  end

  def on_error(error_token_id, error_value, value_stack)
    puts "Parse error on token: #{error_token_id} with value: #{error_value}"
  end

  rule
    document: elements
            {
              $1.each { |element| puts element }
            }
    ;

    elements: element elements
            { [$1, *$2] }
            | 
            { [] }
    ;

    element: header
           | paragraph
    ;

    header: HEADER1 TEXT
          { "<h1>#{$2}</h1>" }
          | HEADER2 TEXT
          { "<h2>#{$2}</h2>" }
          | HEADER3 TEXT
          { "<h3>#{$2}</h3>" }
    ;

    paragraph: TEXT
             { "<p>#{$1}</p>" }
             | formatted_text
    ;

    formatted_text: BOLD TEXT BOLD
                  { "<b>#{$2}</b>" }
                  | ITALIC TEXT ITALIC
                  { "<i>#{$2}</i>" }
    ;
end
```

### Main Script

Finally, we'll create a main script to tie the lexer and parser together and parse some sample markdown-like text.

```ruby
# main.rb
require './lexer'
require './parser'

input = <<-EOS
# Header 1
## Header 2
### Header 3
This is a paragraph.
**This is bold text.**
*This is italic text.*
EOS

lexer = Lexer.new(input)
parser = MarkdownParser.new(lexer)
parser.parse
```

### Running the Example

To run the example, save the `lexer.rb`, `parser.y`, and `main.rb` files, then run:

```sh
racc parser.y -o parser.rb
ruby main.rb
```

### Expected Output

```html
<h1>Header 1</h1>
<h2>Header 2</h2>
<h3>Header 3</h3>
<p>This is a paragraph.</p>
<b>This is bold text.</b>
<i>This is italic text.</i>
```

### Explanation

1. **Lexer**:
   - The lexer splits the input text into lines and matches each line against predefined regular expressions to generate tokens (`HEADER1`, `HEADER2`, `BOLD`, `ITALIC`, `TEXT`).

2. **Parser**:
   - The parser defines rules for document structure using Racc's syntax. It converts tokens into HTML tags based on the grammar rules.

3. **Main Script**:
   - The main script initializes the lexer with the input text, creates an instance of the parser, and then parses the input to generate HTML output.

This example demonstrates how to use Racc to parse a simple markdown-like language and convert it into HTML. You can extend this grammar further to support more markdown features.


---

## q: can you add an error recovery to element or elements?

a:  Sure! Error recovery can be added to the `elements` and `element` rules to handle errors gracefully. In Racc, you can use the `error` token to specify what to do when a syntax error is encountered. Hereâ€™s how you can modify the parser to include error recovery:

### Updated Parser with Error Recovery

```ruby
# parser.y
require 'racc/parser'
require './lexer'

class MarkdownParser < Racc::Parser
  def initialize(lexer)
    @lexer = lexer
  end

  def next_token
    @lexer.next_token
  end

  def on_error(error_token_id, error_value, value_stack)
    puts "Parse error on token: #{error_token_id} with value: #{error_value} at line #{@lexer.lineno}"
  end

  rule
    document: elements
            {
              $1.each { |element| puts element }
            }
    ;

    elements: element elements
            { [$1, *$2] }
            | /* empty */
            { [] }
            | error elements
            { puts "Skipping invalid element."; $2 }
            ;

    element: header
           | paragraph
           | error
           { puts "Skipping invalid content."; nil }
    ;

    header: HEADER1 TEXT
          { "<h1>#{$2}</h1>" }
          | HEADER2 TEXT
          { "<h2>#{$2}</h2>" }
          | HEADER3 TEXT
          { "<h3>#{$2}</h3>" }
    ;

    paragraph: TEXT
             { "<p>#{$1}</p>" }
             | formatted_text
    ;

    formatted_text: BOLD TEXT BOLD
                  { "<b>#{$2}</b>" }
                  | ITALIC TEXT ITALIC
                  { "<i>#{$2}</i>" }
    ;
end
```

### Explanation

1. **Error Token**:
   - The `error` token is used to handle syntax errors. When a syntax error is encountered, the parser will attempt to recover by following the rules specified with the `error` token.

2. **Error Recovery in `elements`**:
   - If an error is encountered within `elements`, the parser will print a message "Skipping invalid element." and continue parsing the remaining `elements`.

3. **Error Recovery in `element`**:
   - If an error is encountered within an `element`, the parser will print a message "Skipping invalid content." and return `nil` to indicate that the invalid element is skipped.

4. **`on_error` Method**:
   - The `on_error` method is overridden to print a detailed error message, including the token that caused the error and the line number where the error occurred.

### Main Script

The main script remains the same as before:

```ruby
# main.rb
require './lexer'
require './parser'

input = <<-EOS
# Header 1
## Header 2
### Header 3
This is a paragraph.
**This is bold text.**
*This is italic text.*
Invalid content here
EOS

lexer = Lexer.new(input)
parser = MarkdownParser.new(lexer)
parser.parse
```

### Running the Example

To run the example, save the `lexer.rb`, `parser.y`, and `main.rb` files, then run:

```sh
racc parser.y -o parser.rb
ruby main.rb
```

### Expected Output

```html
<h1>Header 1</h1>
<h2>Header 2</h2>
<h3>Header 3</h3>
<p>This is a paragraph.</p>
<b>This is bold text.</b>
<i>This is italic text.</i>
Parse error on token: TEXT with value: Invalid content here at line 10
Skipping invalid content.
```

With this setup, the parser will handle errors gracefully, print appropriate messages, and continue parsing the valid parts of the input. You can further customize the error recovery behavior based on your specific requirements.







