#!/usr/bin/env ruby

## tip: to test run:
##   ruby -I ./lib bin/fbt

require 'sportdb/parser'


require 'optparse'

##
## read textfile 
##   and dump tokens
##
##   fbt  ../openfootball/.../euro.txt








class Linter
   
def self.debug=(value) @@debug = value; end
def self.debug?() @@debug ||= false; end
def debug?()  self.class.debug?; end   
        
   
    attr_reader :errors

def initialize
  @errors = []
end

def errors?() @errors.size > 0; end



  ## note:  colon (:) MUST be followed by one (or more) spaces
  ##      make sure mon feb 12 18:10 will not match
  ##        allow 1. FC KÃ¶ln etc.
  ##               Mainz 05:
  ##           limit to 30 chars max
  ##          only allow  chars incl. intl buut (NOT ()[]/;)
  ##
  ##   Group A:
  ##   Group B:   - remove colon
  ##    or lookup first

  ATTRIB_REGEX = /^  
                   [ ]*?     # slurp leading spaces
                (?<key>[^:|\]\[()\/; -]
                       [^:|\]\[()\/;]{0,30}
                 )
                   [ ]*?     # slurp trailing spaces
                   :[ ]+
                (?<value>.+)
                    [ ]*?   # slurp trailing spaces
                   $
                /ix


def read( path )
  nodes = SportDb::OutlineReader.read( path ) 

  ##  process nodes
  h1 = nil
  orphans = 0    ## track paragraphs's with no heading

  attrib_found = false


  nodes.each do |node|
    type = node[0]
    
    if type == :h1
        h1 = node[1]  ## get heading text
        puts
        puts "  = Heading 1 >#{node[1]}<"
    elsif type == :p

       if h1.nil?
         orphans += 1    ## only warn once 
         puts "!! WARN - no heading for #{orphans} text paragraph(s); skipping parse"
         next
       end

       lines = node[1]

       tokens = []
       lines.each_with_index do |line,i|

        if debug?
         puts
         puts "line >#{line}<"
        end


        ## skip new (experimental attrib syntax)
        m = nil
        if attrib_found == false && 
            m=ATTRIB_REGEX.match( line )
          ## note: check attrib regex AFTER group def e.g.:
          ##         Group A: 
          ##         Group B:  etc.
          ##     todo/fix - change Group A: to Group A etc.
          ##                       Group B: to Group B
           attrib_found = true
           ## logger.debug "skipping key/value line - >#{line}<"
           next
        end

        if attrib_found
          ## check if line ends with dot
          ##  if not slurp up lines to the next do!!!
          ## logger.debug "skipping key/value line - >#{line}<"
          attrib_found = false   if line.end_with?( '.' ) 
              # logger.debug "skipping key/value line (cont.) - >#{line}<"
              next
        end    
    

        t, error_messages = tokenize_with_errors( line )

         if error_messages.size > 0
            ## add to "global" error list
            ##   make a triplet tuple (file / msg / line text)
            error_messages.each do |msg|
                @errors << [ path,
                             msg,
                             line
                           ]
            end
         end

         pp t   if debug?

         tokens << t
       end
       
       ## pp tokens
    else
        pp node
        raise ArgumentError, "unsupported (node) type >#{type}<"
    end
  end  # each node
end  # read
end  # class Linter




  SEASON_RE = %r{ (?:
                       \d{4}-\d{2}
                     | \d{4}(--[a-z0-9_-]+)?
                    )
                  }x
    SEASON = SEASON_RE.source    ## "inline" helper for embedding in other regexes - keep? why? why not?


    ## note: if pattern includes directory add here
    ##     (otherwise move to more "generic" datafile) - why? why not?
    MATCH_RE = %r{ (?: ^|/ )      # beginning (^) or beginning of path (/)
                       #{SEASON}
                     /[a-z0-9_-]+\.txt$  ## txt e.g /1-premierleague.txt
                }x


def find( path, pattern=MATCH_RE )
    datafiles = []

    ## check all txt files
    ## note: incl. files starting with dot (.)) as candidates (normally excluded with just *)
    candidates = Dir.glob( "#{path}/**/{*,.*}.txt" )
    ## pp candidates
    candidates.each do |candidate|
      datafiles << candidate    if pattern.match( candidate )
    end

    ## pp datafiles
    datafiles
 end






 args = ARGV
 opts = { debug: false }

 parser = OptionParser.new do |parser|
  parser.banner = "Usage: #{$PROGRAM_NAME} [options]"

##
## check if git has a offline option?? (use same)
##             check for other tools - why? why not?


  parser.on( "--verbose", "--debug",
               "turn on verbose / debug output (default: #{opts[:debug]} )" ) do |debug|
    opts[:debug] = debug
  end
end
parser.parse!( args )

puts "OPTS:"
p opts
puts "ARGV:"
p args


Linter.debug = true    if opts[:debug]




def expand_args( args )
    paths = []

    args.each do |arg|
        ## check if directory
        if Dir.exist?( arg )
            datafiles = find( arg )
            puts
            puts "  found #{datafiles.size} match txt datafiles in #{arg}"
            pp datafiles
            paths += datafiles
        else
              ## assume it's a file
            paths << arg
        end
    end

    paths
end


paths =  if args.empty?
            [
              '../../../openfootball/euro/2020--europe/euro.txt',
              '../../../openfootball/euro/2024--germany/euro.txt',
            ]
         else
            ## check for directories
            ##   and auto-expand
             
            expand_args( args )
         end




linter = Linter.new


paths.each_with_index do |path,i|
    puts "==> [#{i+1}/#{paths.size}] reading >#{path}<..."
    linter.read( path )
end



if linter.errors?
    puts
    pp linter.errors
    puts "!!   #{linter.errors.size} parse error(s) in #{paths.size} datafiles(s)"
else
    puts "OK   no parse errors found in #{paths.size} datafile(s)"
end

puts "bye"