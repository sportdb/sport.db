#!/usr/bin/env ruby

## tip: to test run:
##   ruby -I ./lib -I ../parser/lib bin/fbx


## our own code
require 'sportdb/formats'



require 'optparse'

##
## read textfile
##   and dump match parse results
##
##   fbt  ../openfootball/.../euro.txt




 args = ARGV
 opts = { debug: false,
          outline: false }

 parser = OptionParser.new do |parser|
  parser.banner = "Usage: #{$PROGRAM_NAME} [options]"

##
## check if git has a offline option?? (use same)
##             check for other tools - why? why not?


  parser.on( "--verbose", "--debug",
               "turn on verbose / debug output (default: #{opts[:debug]})" ) do |debug|
    opts[:debug] = debug
  end

  parser.on( "--outline",
                "turn on outline (only) output (default: #{opts[:outline]})" ) do |outline|
    opts[:outline] = outline
  end
end
parser.parse!( args )

puts "OPTS:"
p opts
puts "ARGV:"
p args





paths =  if args.empty?
            [
              '../../../openfootball/euro/2021--europe/euro.txt',
              '../../../openfootball/euro/2024--germany/euro.txt',
            ]
         else
            ## check for directories
            ##   and auto-expand

            SportDb::Parser::Opts.expand_args( args )
         end







SportDb::MatchParser.debug = true    if opts[:debug]


## errors = []


paths.each_with_index do |path,i|
    puts "==> [#{i+1}/#{paths.size}] reading >#{path}<..."

    txt = read_text( path )
    secs = SportDb::LeagueOutlineReader.parse( txt )
    ## pp secs

    secs.each_with_index do |sec,j|   ## sec(tion)s
      season = sec[:season]
      league = sec[:league]
      stage  = sec[:stage]
      lines  = sec[:lines]

      puts "   section #{j+1}/#{secs.size} -   #{league.name} #{season}, #{stage}  -  #{lines.size} line(s)"

      next if opts[:outline]

=begin
    ### check if event info availabe - use start_date;
      ##    otherwise we have to guess (use a "synthetic" start_date)
      event_info = catalog.events.find_by( season: season,
                                           league: league )

      start = if event_info && event_info.start_date
                  puts "event info found:"
                  puts "  using start date from event: "
                  pp event_info
                  pp event_info.start_date
                  event_info.start_date
              else
=end
     start  =   if season.year?
                  Date.new( season.start_year, 1, 1 )
                else
                  Date.new( season.start_year, 7, 1 )
                end

      parser = SportDb::MatchParser.new( lines,
                                         start )   ## note: keep season start_at date for now (no need for more specific stage date need for now)

      auto_conf_teams,  matches, rounds, groups = parser.parse

      puts ">>> #{auto_conf_teams.size} teams:"
      pp auto_conf_teams
      puts ">>> #{matches.size} matches:"
      ## pp matches
      puts ">>> #{rounds.size} rounds:"
      pp rounds
      puts ">>> #{groups.size} groups:"
      pp groups
    end  # each secs
end  # each paths

=begin
if errors.size > 0
    puts
    pp errors
    puts
    puts "!!   #{errors.size} parse error(s) in #{paths.size} datafiles(s)"
else
    puts
    puts "OK   no parse errors found in #{paths.size} datafile(s)"
end
=end

puts "bye"

